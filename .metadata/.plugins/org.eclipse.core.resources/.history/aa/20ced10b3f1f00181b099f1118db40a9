package com.vikas.crackingchapter3;
import com.vikas.crackingcodinginterview.*;
import java.util.Hashtable;

public class Chapter3 {

	/*Below approach removed duplicate from a linked list by using HashTable*/
	public boolean RmvDuplctFrmLinkedListApproach1(SingleLinkedListVik slv)
	{
		try
		{
			Hashtable<Integer,Integer> ht = new Hashtable<Integer,Integer>();
			SingleLinkNode runner = slv.header;
			SingleLinkNode previous = slv.header;
			if(slv.issinglelength())
			{
				System.out.println("There is only one element in list, Nothing to remove");
				return true;
			}
			if(slv.isempty())
			{
				System.out.println("Linked list is empty, Nothing to remove");
				return true;
			}
			while(runner!=null)
			{
				if(ht.containsKey(runner.data))
				{
					previous.next = runner.next;
					
				}
				else
				{
					ht.put(runner.data, runner.data);
					previous = runner;
				}
				runner = runner.next;
			}
			return true;
		}
		catch(NullPointerException npe){
			System.out.println(npe.getMessage());
			System.out.println(npe.getStackTrace());
			return false;
			}
	}
	
	/*Below approach compares nodes one by one and removes the duplicates*/
	public boolean RmvDuplctFrmLinkedListApproach2(SingleLinkedListVik slv)
	{
		try
		{
			SingleLinkNode runner = slv.header;
			SingleLinkNode previous = slv.header;
			SingleLinkNode current = slv.header;
			if(slv.issinglelength())
			{
				System.out.println("There is only one element in list, Nothing to remove");
				return true;
			}
			if(slv.isempty())
			{
				System.out.println("Linked list is empty, Nothing to remove");
				return true;
			}
			
			while(runner!=null)
			{
				current = runner.next;
				previous = runner;
				while(current!=null)
				{
					if(runner.data==current.data)
					{
						previous.next = current.next;
					}
					else
					{
						previous = current;
					}
					current = current.next;
				}
				runner = runner.next;
			}
			return true;
		}
		catch(NullPointerException npe)
		{
			System.out.println(npe.getMessage());
			System.out.println(npe.getStackTrace());
			return false;
		}
	}
	/*Below method finds the Kth element from last in a single linked list*/
	public int LinkedListKthToLastApproach1(SingleLinkedListVik slv,int k)
	{
		try
		{
			int linkedListLength = 0;
			SingleLinkNode runner = slv.header;
			if(slv.isempty())
			{
				System.out.print("Linked list is empty, nothing to be found");
				return -1;
			}
			
			while(runner!=null)
			{
				linkedListLength++;	
			}
			if(k>linkedListLength)
			{
				System.out.println("Linked list size is less than "+k+"given index is not valid");
				return -1;
			}
			else
			{
				int count = linkedListLength - k;
				runner = slv.header;
				while(count>0)
				{
					runner=runner.next;
				}
				return runner.data;
			}
			
		}
		catch(NullPointerException npe)
		{
			System.out.println(npe.getMessage());
			System.out.println(npe.getStackTrace());
			return -1;
		}
	}
	
	public LinkedListKthToLastApproach2(SingleLinkedListVik slv, int k)
	{
		try{
			
		}
		catch(NullPointerException npe)
		{
			
		}
	}
}
