package com.vikas.crackingcodinginterview;
import java.lang.UnsupportedOperationException;
import java.lang.NullPointerException;

public class SingleLinkedListVik {

	public SingleLinkNode header ;
	public SingleLinkNode tail;
	
	
	public SingleLinkedListVik()
	{
		header = null;
		tail = null;
	}
	
	public SingleLinkedListVik(int data)
	{
		SingleLinkNode node = new SingleLinkNode(data);
		header = tail = node;
	}
	
	
	public boolean addatstart(int value)
	{
		try{
		SingleLinkNode node = new SingleLinkNode(value);
		if(this.isempty())
		{
			header = tail = node;
			return true;
		}
		else
		{
			if(this.issinglelength())
			{
				node.next = header;
				header = node;	
				return true;
			}
			else
			{
				node.next = header;
				header = node;	
				return true;
			}				
		}
		}
		catch(NullPointerException npe)
		{
			System.out.println(npe.getMessage());
			System.out.println(npe.getStackTrace());
			return false;
		}
	}
	
	public boolean addatend(int value)
	{
      try {
		SingleLinkNode node = new SingleLinkNode(value);
		if(this.isempty())
		{
			header = tail = node;
			return true;
		}
		else
		{
			if(this.issinglelength())
			{
				tail.next = node;
				tail = node;
			
			}
			else
			{
				tail.next = node;
				tail = node;
			}
			return true;
		}
      }
      catch(NullPointerException npe){
    	  System.out.println(npe.getMessage());
    	  System.out.println(npe.getStackTrace());
    	  return false;
      }
	}
	
	public boolean addbefore(int before, int value)
	{
		try{
			if(this.isempty())
			{
				System.out.format("String is empty, given element %d is not found",before);
				return false;
			}
			else
			{
				SingleLinkNode runner = header;
				SingleLinkNode previous = header;
				SingleLinkNode node = new SingleLinkNode(value);
				while(runner.data!=before && runner.next!=null)
				{
					previous = runner;
					runner = runner.next;
				}
				if(runner.data==before)
				{
					if(runner == header)
					{
						node.next = header;
						header = node;
					}
					else
					{
						previous.next =  node;
						node.next = runner;
					}
					return false;
				}
				else
				{
					System.out.format("Given element %d is not found",before);
					return false;
				}
			}
		}
		catch(NullPointerException npe)
		{
			System.out.println(npe.getMessage());
			System.out.println(npe.getStackTrace());
			return false;
		}
	}
	
	public boolean addafter(int after, int value)
	{
		if(this.isempty())
		{
			System.out.format("Linked list is empty, given number %d is not found", after);
			return false;
		}
		else
		{
			SingleLinkNode node = new SingleLinkNode(value);
			SingleLinkNode runner = this.header;
			SingleLinkNode previous = this.header;
			while(runner.data!=value && runner.next!=null)
			{
				previous = runner;
				runner = runner.next;				
			}
			if(runner.data==value)
			{
				if(runner == tail)
				{
					tail.next = node;
					tail = node;
				}
			}
		}
	}
	
	public boolean  removefirstnode()
	{
		throw new UnsupportedOperationException();	
	}
	
	public boolean removelastnode()
	{
		throw new UnsupportedOperationException();
	}
	public boolean contains(int data)
	{
		throw new UnsupportedOperationException();
	}
	
	public boolean isempty()
	{
		throw new UnsupportedOperationException();
	}
	
	public boolean issinglelength()
	{
		throw new UnsupportedOperationException();
	}
}
